<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Git absorb 소개 - cjlee38</title>
<meta name=theme-color><meta name=description content="어디서 처음 봤는지는 정확히 기억 안나지만, 우연히 괜찮은 git 관련 오픈소스를 발견해서 소개해본다. 이름은 git absorb 라고, git 기반의 일종의 extension 인데, commit history를 관리할 때 유용하게 사용할 수 있다. 먼저 어떤 extension 인지 서두에 정리해보자면, 내가 코드를 수정한 뒤, 해당 작업을 과거의 commit 어딘가에 같이 포함시키고 싶을 때, “가장 관련성이 높은 commit을 찾아”서 흡수시킬 수 있다.
fixup commit 먼저 git absorb 를 알기 전에 먼저 알아둬야 하는 것이 있는데, 바로 fixup commit이다."><meta name=author content="cjlee38"><link rel="preload stylesheet" as=style href=https://cjlee.io/blog/main.min.css><link rel=preload as=image href=https://cjlee.io/blog/theme.png><script defer src=https://cjlee.io/blog/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://cjlee.io/blog/favicon.ico><link rel=apple-touch-icon href=https://cjlee.io/blog/apple-touch-icon.png><meta name=generator content="Hugo 0.127.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta itemprop=name content="Git absorb 소개"><meta itemprop=description content="어디서 처음 봤는지는 정확히 기억 안나지만, 우연히 괜찮은 git 관련 오픈소스를 발견해서 소개해본다. 이름은 git absorb 라고, git 기반의 일종의 extension 인데, commit history를 관리할 때 유용하게 사용할 수 있다. 먼저 어떤 extension 인지 서두에 정리해보자면, 내가 코드를 수정한 뒤, 해당 작업을 과거의 commit 어딘가에 같이 포함시키고 싶을 때, “가장 관련성이 높은 commit을 찾아”서 흡수시킬 수 있다.
fixup commit 먼저 git absorb 를 알기 전에 먼저 알아둬야 하는 것이 있는데, 바로 fixup commit이다."><meta itemprop=datePublished content="2024-06-05T00:00:00+00:00"><meta itemprop=dateModified content="2024-06-05T00:00:00+00:00"><meta itemprop=wordCount content="592"><meta itemprop=keywords content="Git,Absorb"><meta property="og:url" content="https://cjlee.io/blog/post/git-absorb/"><meta property="og:site_name" content="cjlee38"><meta property="og:title" content="Git absorb 소개"><meta property="og:description" content="어디서 처음 봤는지는 정확히 기억 안나지만, 우연히 괜찮은 git 관련 오픈소스를 발견해서 소개해본다. 이름은 git absorb 라고, git 기반의 일종의 extension 인데, commit history를 관리할 때 유용하게 사용할 수 있다. 먼저 어떤 extension 인지 서두에 정리해보자면, 내가 코드를 수정한 뒤, 해당 작업을 과거의 commit 어딘가에 같이 포함시키고 싶을 때, “가장 관련성이 높은 commit을 찾아”서 흡수시킬 수 있다.
fixup commit 먼저 git absorb 를 알기 전에 먼저 알아둬야 하는 것이 있는데, 바로 fixup commit이다."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-06-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-05T00:00:00+00:00"><meta property="article:tag" content="Git"><meta property="article:tag" content="Absorb"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git absorb 소개"><meta name=twitter:description content="어디서 처음 봤는지는 정확히 기억 안나지만, 우연히 괜찮은 git 관련 오픈소스를 발견해서 소개해본다. 이름은 git absorb 라고, git 기반의 일종의 extension 인데, commit history를 관리할 때 유용하게 사용할 수 있다. 먼저 어떤 extension 인지 서두에 정리해보자면, 내가 코드를 수정한 뒤, 해당 작업을 과거의 commit 어딘가에 같이 포함시키고 싶을 때, “가장 관련성이 높은 commit을 찾아”서 흡수시킬 수 있다.
fixup commit 먼저 git absorb 를 알기 전에 먼저 알아둬야 하는 것이 있는데, 바로 fixup commit이다."><link rel=canonical href=https://cjlee.io/blog/post/git-absorb/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://cjlee.io/blog/>cjlee38</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/blog/categories/>categories</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/blog/tags/>tags</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Git absorb 소개</h1><div class="text-sm antialiased opacity-60"><time>Jun 5, 2024</time></div></header><section><p>어디서 처음 봤는지는 정확히 기억 안나지만, 우연히 괜찮은 git 관련 오픈소스를 발견해서 소개해본다. 이름은 <code>git absorb</code> 라고, <code>git</code> 기반의 일종의 extension 인데, commit history를 관리할 때 유용하게 사용할 수 있다. 먼저 어떤 extension 인지 서두에 정리해보자면, 내가 코드를 수정한 뒤, 해당 작업을 과거의 commit 어딘가에 같이 포함시키고 싶을 때, “가장 관련성이 높은 commit을 찾아”서 흡수시킬 수 있다.</p><h3 id=fixup-commit>fixup commit</h3><p>먼저 <code>git absorb</code> 를 알기 전에 먼저 알아둬야 하는 것이 있는데, 바로 <code>fixup commit</code>이다. manpage(<code>man git-commit 1</code>) 에도 설명이 잘 나와있는데, commit 을 수행할 때 단순히 새로운 commit 을 추가하는게 아니라, 이전의 commit 과 “합칠 수 있는” commit을 제공한다.</p><p>가령, 아래와 같이 <code>a.txt</code> 파일을 만들고 commit 한번 <code>b.txt</code> 파일을 만들고 commit 한 번으로, 총 두 번의 commit 을 통해 아래와 같이 commit history가 있다고 가정해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ee8f6a4 second <span style=color:#75715e># b.txt</span>
</span></span><span style=display:flex><span>8eb5b88 first <span style=color:#75715e># a.txt</span>
</span></span></code></pre></div><p>이 상황에서, <code>a.txt</code> 파일에 누락된 사항을 뒤늦게 발견했다고 가정해보자. 새로운 commit 을 만들기는 싫고, 과거의 commit 에 그대로 포함시키고 싶다면 어떻게 해야할까 ? 가장 익숙한(?) 방법은 아마 <code>git reset</code> 을 통해 commit history 를 제거하고, <code>git commit --amend</code> 와 같은 명령어를 이용해서 누락된 수정사항을 포함시킨 뒤, 다시 commit 을 수행하는 방법이다.</p><p>하지만, 목표 commit 에 도달하기까지 수많은 commit history 가 이미 존재하는 상황이라면, <code>--fixup</code> commit을 통해 손쉽게 해결할 수 있다. 사용 방법은 간단하다. 아래와 같이 파라미터를 넘겨주면 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git commit --fixup<span style=color:#f92672>=</span>8eb5b88 <span style=color:#75715e># `first` commit</span>
</span></span></code></pre></div><p>그리고 <code>git log</code> 를 통해 살펴보면 다음과 같이 ‘fixup commit’ 이 추가된다</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># git log --oneline</span>
</span></span><span style=display:flex><span>e23e811 <span style=color:#f92672>(</span>HEAD -&gt; main<span style=color:#f92672>)</span> fixup! first
</span></span><span style=display:flex><span>ee8f6a4 second
</span></span><span style=display:flex><span>8eb5b88 first
</span></span></code></pre></div><p>이후, <code>git rebase -i --autosquash &lt;commit-id></code> 를 통해 interactive rebase 를 진행하면, 다음과 같이 fixup commit 이 수정하고자 하는 commit 바로 아래에 자동으로 위치하게 된다. (commit-id 는 first commit 보다 이전 commit id 로 지정한다.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># vim editor</span>
</span></span><span style=display:flex><span>pick 8eb5b88 first
</span></span><span style=display:flex><span>fixup e23e811 fixup! first
</span></span><span style=display:flex><span>pick ee8f6a4 second
</span></span></code></pre></div><p>그대로 저장하고 나와서 rebase 를 수행하면 (별도의 conflict 가 없다면) fixup commit 이 first commit 으로 포함되어 들어가게 된다. (이 외에도 <code>squash commit</code>, <code>amend commit</code> 도 존재한다)</p><h3 id=git-absorb>git absorb</h3><p>git absorb 는 수정사항이 “어느 commit 으로 포함되어야 하는지” 를 알아서 찾아서, <code>fixup commit</code> 단계를 스킵하도록 해준다.</p><p>위 예시에서, <code>fixup commit</code> 을 수행하는 대신, <code>git absorb</code> 를 입력하면, <code>fixup commit</code> 을 대신 수행해준다. 이 때 어떤 commit 으로 fixup 할 것인지에 대한 판단은 file change 를 기준으로 선정한다. (사실 좀 더 정확한 알고리즘은 <a href="https://github.com/tummychow/git-absorb?tab=readme-ov-file#how-it-works-roughly">이곳</a> 에 나와있다)</p><blockquote><p>The command essentially looks at the lines that were modified, finds a changeset modifying those lines, and amends that changeset to include your uncommitted changes.</p></blockquote><p>그렇기에, 앞서 이야기했듯 누락된, 즉 수정된 부분은 <code>a.txt</code> 이고, 해당 commit 은 ‘first commit’ 이므로 아래와 같이 해당 commit 으로의 <code>fixup commit</code> 을 수행한다. 반대로 만약 수정한 파일이 <code>b.txt</code> 였다면 &lsquo;second commit&rsquo; 으로 fixup commit 이 수행되었을 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># git log --oneline</span>
</span></span><span style=display:flex><span>e23e811 <span style=color:#f92672>(</span>HEAD -&gt; main<span style=color:#f92672>)</span> fixup! first
</span></span><span style=display:flex><span>ee8f6a4 second
</span></span><span style=display:flex><span>8eb5b88 first
</span></span></code></pre></div><p>또한, 이 <code>fixup commit</code> 은 hunk 단위로 수행되기 때문에, 여러 파일을 수정했다면 각 hunk에 걸맞는 <code>fixup commit</code> 을 만들어낸다.</p><h3 id=주의사항>주의사항</h3><p>단, 이렇게 git absorb 를 사용할 때에는 몇 가지를 고려해야 한다.(사실은 <code>git absorb</code> 보단, <code>fixup commit</code> 자체에 대한 고려사항이다.)</p><p>아마 대부분의 상황에서, 팀 단위의 협업으로 코드를 수정할 때는 Pull Request(Merge Request) 로 코드리뷰를 진행하고, 이를 merge 하는 방식으로 진행할텐데, 이 때 squash merge 를 하는 경우에는 사실 상 이 기능이 필요없을 것이다.</p><p>반대로, merge commit 을 하는 경우에는 유용하게 사용될 수 있다. 피쳐 브랜치에서 수행한 commit 이 main stream 브랜치 commit history 에 그대로 반영되므로, 가급적 깔끔하게 유지해야 할 것이고 이 때 fixup commit 이 도움을 줄 수 있다. 하지만 여전히 코드리뷰 단계에서 <code>fixup commit</code> 을 수행하면 force push 를 해야하는 상황이 발생한다.</p><p>심지어 PR 을 사용하지 않는다면 훨씬 더 심각한 문제(<a href=https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-Rebase-%ED%95%98%EA%B8%B0#_rebase_peril>예를 들면 이런 상황</a>)를 초래할 수 있다는 점에 유의하자.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://cjlee.io/blog/tags/git>git</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://cjlee.io/blog/tags/absorb>absorb</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://cjlee.io/blog/post/oop-is-psychotic-disorder/><span>객체지향은 정신병이다.</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://cjlee.io/blog/>cjlee38</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>